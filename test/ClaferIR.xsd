<!-- ........................................................................ *
  *   Clafer Project                                                          *
  *   http://clafer.org                                                       *
  *                                                                           *
  *   File description: XML schema of Clafer intermediate representation (IR) *
  *   Depends on: Haskell IR data types defined for clafer (Intclafer.hs)     *
  *   Author: Leonardo Passos <lpassos@gsd.uwaterloo.ca>                      *
  *   Contributors: Jimmy Liang <jliang@gsd.uwaterloo.ca>                     *
  *                 Michal Antkiewicz <mantkiew@gsd.uwaterloo.ca>             *
  *   Date: October 19th, 2011                                                *
  *   Last update: February 4th, 2015                                         *
  * ......................................................................... *
  */
-->
<xs:schema targetNamespace="http://clafer.org/ir"
           elementFormDefault="qualified"
           xmlns="http://clafer.org/ir"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:cl="http://clafer.org/ir">

  <!-- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .-->
  <!--
data IType
  = TBoolean
  | TString
  | TInteger
  | TReal
  | TClafer [UID]
  -->
  <xs:complexType name="IType" abstract="true"/>
  <xs:element name="Type" type="cl:IType"/>

  <xs:complexType name="IBoolean">
      <xs:complexContent>
          <xs:extension base="cl:IType"/>
      </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IString">
      <xs:complexContent>
          <xs:extension base="cl:IType"/>
      </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IInteger">
      <xs:complexContent>
          <xs:extension base="cl:IType"/>
      </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IReal">
      <xs:complexContent>
          <xs:extension base="cl:IType"/>
      </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ISet">
      <xs:complexContent>
          <xs:extension base="cl:IType"/>
      </xs:complexContent>
  </xs:complexType>

  <!-- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .-->
  <!--
data IModule
  = IModule
    { _mName :: String
    , _mDecls :: [IElement]
    }
  -->

  <xs:complexType name="IModule">
      <xs:sequence>
          <xs:element name="Name" type="xs:string"/>
          <xs:element ref="Declaration" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
  </xs:complexType>

  <xs:element name="Module" type="cl:IModule"/>

  <!-- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .-->
  <!--
data IClafer
  = IClafer
    { _cinPos :: Span
    , _isAbstract :: Bool
    , _gcard :: Maybe IGCard
    , _ident :: CName
    , _uid :: UID
    , _parentUID :: UID
    , _super :: Maybe PExp
    , _reference :: Maybe IReference
    , _card :: Maybe Interval
    , _glCard :: Interval
    , _elements :: [IElement]
    }
  -->
  <xs:complexType name="IClafer">
      <xs:complexContent>
          <xs:extension base="IElement">
            <xs:sequence>
                <xs:element name="Position">
                  <xs:complexType>
                      <xs:sequence>
                          <xs:element name="Start">
                              <xs:complexType>
                                  <xs:sequence>
                                      <xs:element ref="IntLiteral" minOccurs="2" maxOccurs="2"/>
                                  </xs:sequence>
                              </xs:complexType>
                          </xs:element>
                          <xs:element name="End">
                              <xs:complexType>
                                  <xs:sequence>
                                      <xs:element ref="IntLiteral" minOccurs="2" maxOccurs="2"/>
                                  </xs:sequence>
                              </xs:complexType>
                          </xs:element>
                      </xs:sequence>
                  </xs:complexType>
                </xs:element>
                <xs:element name="IsAbstract" type="xs:boolean"/>
                <xs:element name="GroupCard"  type="cl:IGroupCard" minOccurs="0" maxOccurs="1"/>
                <xs:element name="Id"         type="xs:string"/>
                <xs:element name="UniqueId"   type="xs:string"/>
                <xs:element name="ParentUniqueId" type="xs:string"/>
                <xs:element name="Super"      type="cl:IParentExp" minOccurs="0" maxOccurs="1"/>
                <xs:element name="Reference"  type="cl:IReference" minOccurs="0" maxOccurs="1"/>
                <xs:element name="Card"       type="cl:IInterval" minOccurs="0" maxOccurs="1"/>
                <xs:element name="GlobalCard" type="cl:IInterval"/>
                <xs:element ref="Declaration" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>

  <!-- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .-->
  <!--
data IElement
  = IEClafer
    { _iClafer :: IClafer
    }
  | IEConstraint
    { _isHard :: Bool
    , _cpexp :: PExp
    }
  | IEGoal
    { _isMaximize :: Bool
    , _cpexp :: PExp
    }
   -->

  <xs:complexType name="IElement" abstract="true"/>
  <xs:element name="Declaration" type="IElement"/>

  <!-- No need to create IEClafer type. IClafer is already a subtype
       of IElement
    -->

  <xs:complexType name="IConstraint">
    <xs:complexContent>
      <xs:extension base="cl:IElement">
          <xs:sequence>
              <xs:element name="IsHard"    type="xs:boolean"/>
              <xs:element name="ParentExp" type="cl:IParentExp"/>
          </xs:sequence>
      </xs:extension>

    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IGoal">
    <xs:complexContent>
      <xs:extension base="cl:IElement">
          <xs:sequence>
              <xs:element name="IsMaximize" type="xs:boolean"/>
              <xs:element name="ParentExp"  type="cl:IParentExp"/>
          </xs:sequence>
      </xs:extension>

    </xs:complexContent>
  </xs:complexType>

  <!-- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .-->
  <!--
data IReference
  = IReference
    { _isSet :: Bool
    , _ref :: PExp
    }
  -->
  <xs:complexType name="IReference">
    <xs:sequence>
        <xs:element name="IsSet" type="xs:boolean"/>
        <xs:element name="Ref"   type="cl:IParentExp"/>
    </xs:sequence>
  </xs:complexType>

  <!-- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .-->
  <!--
data IGCard
  = IGCard
    { _isKeyword :: Bool
    , _interval :: Interval
    }
  -->

  <xs:complexType name="IGroupCard">
    <xs:sequence>
        <xs:element name="IsKeyword" type="xs:boolean"/>
        <xs:element name="Interval"  type="cl:IInterval"/>
    </xs:sequence>
  </xs:complexType>

  <!-- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .-->
  <!-- type Interval = (Integer, ExInteger) -->

  <xs:complexType name="IInterval">
      <xs:sequence>
          <xs:element name="Min">
            <xs:complexType>
                <xs:sequence>
                    <xs:element ref="IntLiteral"/>
                </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="Max">
            <xs:complexType>
                <xs:sequence>
                    <xs:element ref="IntLiteral"/>
                </xs:sequence>
            </xs:complexType>
          </xs:element>
      </xs:sequence>
  </xs:complexType>

  <!-- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .-->
  <!--
data PExp
  = PExp
    { _iType :: Maybe IType
    , _pid :: String
    , _inPos :: Span
    , _exp :: IExp
    }
  -->

  <xs:complexType name="IParentExp">
      <xs:sequence>
          <xs:element name="Type"     type="cl:IType" minOccurs="0" maxOccurs="1"/>
          <xs:element name="ParentId" type="xs:string" minOccurs="0" maxOccurs="1"/>
          <xs:element name="Position">
              <xs:complexType>
                  <xs:sequence>
                      <xs:element name="Start">
                          <xs:complexType>
                              <xs:sequence>
                                  <xs:element ref="IntLiteral" minOccurs="2" maxOccurs="2"/>
                              </xs:sequence>
                          </xs:complexType>
                      </xs:element>
                      <xs:element name="End">
                          <xs:complexType>
                              <xs:sequence>
                                  <xs:element ref="IntLiteral" minOccurs="2" maxOccurs="2"/>
                              </xs:sequence>
                          </xs:complexType>
                      </xs:element>
                  </xs:sequence>
              </xs:complexType>
          </xs:element>
          <xs:element name="Exp"      type="cl:IExp"/>
      </xs:sequence>
  </xs:complexType>


  <!-- ......................................................................-->
  <!--
data IExp
  = IDeclPExp
    { _quant :: IQuant
    , _oDecls :: [IDecl]
    , _bpexp :: PExp
    }
  | IFunExp
    { _op :: String
    , _exps :: [PExp]
    }
  | IInt
    { _iint :: Integer
    }
  | IDouble
    { _idouble :: Double
    }
  | IStr
    { _istr :: String
    }
  | IClaferId
    { _modName :: String
    , _sident :: CName
    , _isTop :: Bool
    , _binding :: ClaferBinding
    }
   -->
  <xs:complexType name="IExp" abstract="true"/>

  <xs:complexType name="IDeclarationParentExp">
      <xs:complexContent>
          <xs:extension base="cl:IExp">
              <xs:sequence>
                  <xs:element name="Quantifier"    type="cl:IQuantifier"/>
                  <xs:element name="Declaration"   type="cl:IDeclaration" minOccurs="0" maxOccurs="unbounded"/>
                  <xs:element name="BodyParentExp" type="cl:IParentExp"/>
              </xs:sequence>
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IFunctionExp">
      <xs:complexContent>
          <xs:extension base="IExp">
              <xs:sequence>
                  <xs:element name="Operation" type="xs:string"/>
                  <xs:element name="Argument" minOccurs="0" maxOccurs="unbounded" type="IParentExp"/>
              </xs:sequence>
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IIntExp">
      <xs:complexContent>
          <xs:extension base="IExp">
              <xs:sequence>
                 <xs:element ref="IntLiteral"/>
              </xs:sequence>
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IDoubleExp">
      <xs:complexContent>
          <xs:extension base="IExp">
              <xs:sequence>
                 <xs:element ref="DoubleLiteral"/>
              </xs:sequence>
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IStringExp">
      <xs:complexContent>
          <xs:extension base="IExp">
              <xs:sequence>
                 <xs:element ref="StringLiteral"/>
              </xs:sequence>
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>


  <xs:complexType name="IClaferId">
      <xs:complexContent>
          <xs:extension base="IExp">
              <xs:sequence>
                  <xs:element name="ModuleName" type="xs:string" minOccurs="0" maxOccurs="1"/>
                  <xs:element name="Id"         type="xs:string" />
                  <xs:element name="IsTop"      type="xs:boolean"/>
                  <xs:element name="Bind"    type="xs:string" />
              </xs:sequence>
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>

  <!-- ......................................................................-->
  <!--
data IDecl
  = IDecl
    { _isDisj :: Bool
    , _decls :: [CName]
    , _body :: PExp
    }
    -->

   <xs:complexType name="IDeclaration">
       <xs:sequence>
           <xs:element name="IsDisjunct"       type="xs:boolean"/>
           <xs:element name="LocalDeclaration" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
           <xs:element name="Body"             type="cl:IParentExp"/>
       </xs:sequence>
   </xs:complexType>

  <!-- ......................................................................-->
  <!--
data IQuant
  = INo
  | ILone
  | IOne
  | ISome
  | IAll
   -->

   <xs:complexType name="IQuantifier" abstract="true"/>

   <xs:complexType name="INo">
       <xs:complexContent>
           <xs:extension base="cl:IQuantifier"/>
       </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="ILone">
       <xs:complexContent>
           <xs:extension base="cl:IQuantifier"/>
       </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="IOne">
       <xs:complexContent>
           <xs:extension base="cl:IQuantifier"/>
       </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="ISome">
       <xs:complexContent>
           <xs:extension base="cl:IQuantifier"/>
       </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="IAll">
       <xs:complexContent>
           <xs:extension base="cl:IQuantifier"/>
       </xs:complexContent>
   </xs:complexType>

 <!-- ......................................................................-->

 <xs:element name="IntLiteral"    type="xs:integer"/>
 <xs:element name="DoubleLiteral" type="xs:double"/>
 <xs:element name="StringLiteral" type="xs:string"/>

</xs:schema>
