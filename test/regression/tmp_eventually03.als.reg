/*
All clafers: 2 | Abstract: 0 | Concrete: 2 | References: 0
Constraints: 2
Goals: 0
Global scope: 1..1
Can skip resolver: yes
*/

open util/ordering[Time]
pred show {}
run show for 10

sig Time {loop: lone Time}
fact Loop {loop in last->Time}
fun timeLoop: Time -> Time { Time <: next + loop }

one sig root
{ r_c0_a : c0_a -> Time }
{ all t : Time | one r_c0_a.t }

sig c0_a
{ r_c0_b : c0_b -> Time }
{ all t : Time | one @r_c0_a.t.this
  all t : Time | lone r_c0_b.t
  let local_next = (this.(root.@r_c0_a)) <: next  | one t : Time | one t <: local_next and no local_next :> t and 
  (some t':t.*timeLoop | (let t''=t'.timeLoop | some t'' and some this.@r_c0_b.t'')) }

sig c0_b
{}
{ all t : Time | one @r_c0_b.t.this }




assert assertOnLine_5 { one t : first <: Time | (some loop and all t':t.*timeLoop | no @r_c0_a.t'.@r_c0_b.t') }
check assertOnLine_5 for 10

